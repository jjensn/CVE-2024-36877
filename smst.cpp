#include "globals.hpp"

static
PVOID
MemMem(
    const void* SearchBase,
    SIZE_T SearchSize,
    const void* Pattern,
    SIZE_T PatternSize,
    SIZE_T Alignment
)
{
    if (PatternSize > SearchSize)
    {
        return nullptr;
    }

    Alignment = (Alignment == 0) ? 1 : Alignment;

    auto searchBase = static_cast<const char*>(SearchBase);
    for (SIZE_T i = 0; i <= SearchSize - PatternSize; i += Alignment)
    {
        if (!memcmp(Pattern, &searchBase[i], PatternSize))
        {
            return const_cast<char*>(&searchBase[i]);
        }
    }
    return nullptr;
}

class MemoryScanner
{
public:
    NTSTATUS
        Initialize(
            const PhysicalMemory& Pm
        );

    ULONG64
        Scan(
            ULONG64 ScanBase,
            SIZE_T ScanLength,
            const void* Pattern,
            SIZE_T PatternLength,
            SIZE_T Alignment
        ) const;

    ~MemoryScanner(
    );

private:
    const PhysicalMemory* m_Pm;
    mutable PVOID m_ScanBuffer;
};

NTSTATUS
MemoryScanner::Initialize(
    const PhysicalMemory& Pm
)
{
    NTSTATUS status;
    PVOID scanBuffer;

    scanBuffer = ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, k_PoolTag);
    if (scanBuffer == nullptr)
    {
        DEBUGMSG("Memory allocation failed : %lu", PAGE_SIZE);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    status = STATUS_SUCCESS;
    m_Pm = &Pm;
    m_ScanBuffer = scanBuffer;

Exit:
    return status;
}

ULONG64
MemoryScanner::Scan(
    ULONG64 ScanBase,
    SIZE_T ScanLength,
    const void* Pattern,
    SIZE_T PatternLength,
    SIZE_T Alignment
) const
{
    for (ULONG64 pageOffset = 0; pageOffset < ScanLength; pageOffset += PAGE_SIZE)
    {
        NTSTATUS status;
        PVOID found;

        status = m_Pm->Read(m_ScanBuffer, ScanBase + pageOffset, PAGE_SIZE);
        if (!NT_SUCCESS(status))
        {
            //
            // Noisy. Try the next segment.
            //
            //DEBUGMSG("Read failed : %08x", status);
            break;
        }

        found = MemMem(m_ScanBuffer, PAGE_SIZE, Pattern, PatternLength, Alignment);
        if (found != nullptr)
        {
            ULONG64 byteOffset;

            byteOffset = reinterpret_cast<ULONG64>(found) - reinterpret_cast<ULONG64>(m_ScanBuffer);
            return ScanBase + pageOffset + byteOffset;
        }
    }
    return 0;
}

MemoryScanner::~MemoryScanner(
)
{
    if (m_ScanBuffer != nullptr)
    {
        ExFreePoolWithTag(m_ScanBuffer, k_PoolTag);
    }
}

static
NTSTATUS
FindSmmCorePrivateData(
    const MemoryScanner& Scanner,
    PULONG64 SmmcAddress
)
{
    //
    // Parse the registry entry and scan the physical memory ranges indicated by this.
    // Kudos to Alex Ionescu (@aionescu) for sharing this trick with me.
    //
    static UNICODE_STRING key =
        RTL_CONSTANT_STRING(L"\\REGISTRY\\MACHINE\\HARDWARE\\RESOURCEMAP\\System Resources\\Loader Reserved");
    static OBJECT_ATTRIBUTES attributes =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&key, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
    static UNICODE_STRING valueName = RTL_CONSTANT_STRING(L".Raw");

    NTSTATUS status;
    HANDLE keyHandle;
    PKEY_VALUE_FULL_INFORMATION buffer;
    ULONG resultLength;
    CM_RESOURCE_LIST* list;

    *SmmcAddress = 0;
    buffer = nullptr;

    status = ZwOpenKey(&keyHandle, KEY_ALL_ACCESS, &attributes);
    if (!NT_SUCCESS(status))
    {
        DEBUGMSG("ZwOpenKey failed : %08x", status);
        goto Exit;
    }

    buffer = static_cast<PKEY_VALUE_FULL_INFORMATION>(
        ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, k_PoolTag));
    if (buffer == nullptr)
    {
        DEBUGMSG("Memory allocation failed : %lu", PAGE_SIZE);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    status = ZwQueryValueKey(keyHandle,
        &valueName,
        KeyValueFullInformation,
        buffer,
        PAGE_SIZE,
        &resultLength);
    if (!NT_SUCCESS(status))
    {
        DEBUGMSG("ZwQueryValueKey failed : %08x", status);
        goto Exit;
    }

    list = static_cast<CM_RESOURCE_LIST*>(Add2Ptr(buffer, buffer->DataOffset));
    for (ULONG64 i = 0; i < list->Count; ++i)
    {
        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor;

        fullDescriptor = &list->List[i];
        for (ULONG64 j = 0; j < fullDescriptor->PartialResourceList.Count; ++j)
        {
            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
            ULONG64 foundAddress;

            partial = &fullDescriptor->PartialResourceList.PartialDescriptors[j];
            if ((partial->Type != CmResourceTypeMemory) ||
                (partial->Flags != CM_RESOURCE_PORT_MEMORY))
            {
                DEBUGMSG("Unexpected entry");
                continue;
            }

            static constexpr ULONG64 smmcSignature = 'cmms';
            foundAddress = Scanner.Scan(partial->u.Memory.Start.QuadPart,
                partial->u.Memory.Length,
                &smmcSignature,
                sizeof(smmcSignature),
                sizeof(smmcSignature));
            if (foundAddress != 0)
            {
                *SmmcAddress = foundAddress;
                status = STATUS_SUCCESS;
                goto Exit;
            }
        }
    }

    status = STATUS_NOT_FOUND;

Exit:
    if (buffer != nullptr)
    {
        ExFreePoolWithTag(buffer, k_PoolTag);
    }
    if (keyHandle != nullptr)
    {
        ZwClose(keyHandle);
    }
    return status;
}

NTSTATUS
FindSystemManagementServiceTable(
    PhysicalMemory& Pm,
    PULONG64 SmstAddress
)
{
    NTSTATUS status;
    SMM_CORE_PRIVATE_DATA* smmcAddress;
    ULONG64 smstAddress;
    MemoryScanner scanner;

    status = scanner.Initialize(Pm);
    if (!NT_SUCCESS(status))
    {
        DEBUGMSG("Initialize failed : %08x", status);
        goto Exit;
    }

    status = FindSmmCorePrivateData(scanner, reinterpret_cast<PULONG64>(&smmcAddress));
    if (!NT_SUCCESS(status))
    {
        DEBUGMSG("FindSmmCorePrivateData failed : %08x", status);
        goto Exit;
    }
    DEBUGMSG("SMM core found at 0x%llx in RT Code", (UINT64)smmcAddress);

    status = Pm.Read(&smstAddress,
        reinterpret_cast<ULONG64>(&smmcAddress->Smst),
        sizeof(smstAddress));
    if (!NT_SUCCESS(status))
    {
        DEBUGMSG("Read failed : %08x", status);
        goto Exit;
    }

    DEBUGMSG("SMST found at 0x%llx in SMRAM", smstAddress);
    *SmstAddress = smstAddress;

Exit:
    return status;
}
